{"id": "e1687e83-b1f2-4ad0-8d5a-99701b246bd5", "code": "# initial_program.py\n# This file is evolved by AlphaEvolve\n# Only update_rho (and helpers) should be modified\n\nimport numpy as np\n\n\ndef tau(k, c=1.0, p=1.2):\n    \"\"\"\n    Diminishing step size, must be summable.\n    AlphaEvolve is allowed to change this.\n    \"\"\"\n    return c / ((k + 1) ** p)\n\n\ndef update_rho(\n    rho,\n    k,\n    r_norm,\n    s_norm,\n    mu=3.0,\n    c=1.0,\n    p=1.2,\n    eps=1e-12,\n):\n    \"\"\"\n    Adaptive ADMM penalty update rule.\n\n    Inputs:\n        rho    : current penalty parameter\n        k      : iteration index\n        r_norm : ||primal residual||\n        s_norm : ||dual residual||\n    Outputs:\n        new_rho : updated rho\n        aux     : any auxiliary scalar (logged but not used)\n        mode    : string label (\"mul\", \"div\", \"keep\", etc.)\n\n    AlphaEvolve may change the internal logic,\n    but MUST respect the signature and return types.\n    \"\"\"\n\n    t = tau(k, c, p)\n    # Early iterations: more aggressive, later: more conservative\n    # Use a dynamic threshold that tightens over time\n    # mu is scaled by (1 + t) to be more permissive early, stricter later\n    dynamic_mu = mu * (1.0 + 2.0 * t)  # Starts larger, decreases to mu\n    \n    # Compute the ratio of residuals\n    ratio = r_norm / max(s_norm, eps)\n    \n    # If ratio is too large, increase rho; if too small, decrease rho\n    # But we want to avoid oscillating, so update smoothly\n    # Target ratio is 1.0\n    if ratio > dynamic_mu:\n        # Increase rho to reduce primal residual\n        # Update factor based on sqrt(ratio) but bounded\n        fac = np.sqrt(ratio)\n        # Clip factor to prevent extreme updates\n        fac = min(fac, 1.5)\n        # Make updates more aggressive early on\n        fac = 1.0 + (fac - 1.0) * (1.0 - 0.5 * t)\n        new_rho = rho * fac\n        mode = \"mul\"\n    elif 1.0 / ratio > dynamic_mu:\n        # Decrease rho to reduce dual residual\n        fac = np.sqrt(1.0 / ratio)\n        fac = min(fac, 1.5)\n        fac = 1.0 + (fac - 1.0) * (1.0 - 0.5 * t)\n        new_rho = rho / fac\n        mode = \"div\"\n    else:\n        new_rho = rho\n        mode = \"keep\"\n    \n    # Ensure rho doesn't become too large or too small\n    # Clip to a reasonable range\n    rho_min = 1e-6\n    rho_max = 1e6\n    new_rho = max(rho_min, min(new_rho, rho_max))\n    \n    return new_rho, t, mode\n", "language": "python", "parent_id": "e3e7b7e1-1592-4d78-8c9c-6a76f7a88c15", "generation": 1, "timestamp": 1768219087.7162461, "iteration_found": 4, "metrics": {"combined_score": 0.07533695935828097, "metrics": {"converged": true, "iters": 13, "combined_score": 0.07533695935828097}, "artifacts": {"status": "CONVERGED", "iterations": 13, "eval_time": "0.006s"}}, "complexity": 0.0, "diversity": 0.0, "metadata": {"changes": "Change 1: Replace 10 lines with 40 lines", "parent_metrics": {"combined_score": 0.043007227611818806, "metrics": {"converged": true, "iters": 23, "combined_score": 0.043007227611818806}, "artifacts": {"status": "CONVERGED", "iterations": 23, "eval_time": "0.021s"}}, "island": 0}, "prompts": {"diff_user": {"system": "You are an expert in numerical optimization and ADMM algorithms.\n\nYour task is to improve the function update_rho(rho, k, r_norm, s_norm, ...)\nused to adaptively update the ADMM penalty parameter.\n\nGoals:\n- Achieve faster convergence (fewer ADMM iterations)\n- Maintain numerical stability (avoid oscillating rho)\n- Balance primal and dual residuals efficiently\n\nConstraints:\n- You may ONLY modify the body of update_rho and helper functions in initial_program.py\n- The function signature and return types must remain unchanged\n- The code must be deterministic and numerically safe\n\nHints:\n- Consider using ratios or log-ratios of r_norm and s_norm\n- Early iterations may benefit from aggressive updates\n- Later iterations should favor stability\n- Piecewise or stateful strategies are allowed\n", "user": "# Current Program Information\n- Fitness: 0.0430\n- Feature coordinates: \n- Focus areas: - Fitness unchanged at 0.0430\n- No feature coordinates\n- Consider simplifying - code length exceeds 500 characters\n\n\n\n# Program Evolution History\n## Previous Attempts\n\n### Attempt 1\n- Changes: Unknown changes\n- Metrics: combined_score: 0.0430, metrics: {'converged': True, 'iters': 23, 'combined_score': 0.043007227611818806}, artifacts: {'status': 'CONVERGED', 'iterations': 23, 'eval_time': '0.021s'}\n- Outcome: Improvement in all metrics\n\n## Top Performing Programs\n\n### Program 1 (Score: 0.0430)\n```python\n# initial_program.py\n# This file is evolved by AlphaEvolve\n# Only update_rho (and helpers) should be modified\n\nimport numpy as np\n\n\ndef tau(k, c=1.0, p=1.2):\n    \"\"\"\n    Diminishing step size, must be summable.\n    AlphaEvolve is allowed to change this.\n    \"\"\"\n    return c / ((k + 1) ** p)\n\n\ndef update_rho(\n    rho,\n    k,\n    r_norm,\n    s_norm,\n    mu=3.0,\n    c=1.0,\n    p=1.2,\n    eps=1e-12,\n):\n    \"\"\"\n    Adaptive ADMM penalty update rule.\n\n    Inputs:\n        rho    : current penalty parameter\n        k      : iteration index\n        r_norm : ||primal residual||\n        s_norm : ||dual residual||\n    Outputs:\n        new_rho : updated rho\n        aux     : any auxiliary scalar (logged but not used)\n        mode    : string label (\"mul\", \"div\", \"keep\", etc.)\n\n    AlphaEvolve may change the internal logic,\n    but MUST respect the signature and return types.\n    \"\"\"\n\n    t = tau(k, c, p)\n    fac = 0.85 + t\n\n    if r_norm > mu * max(s_norm, eps):\n        return rho * fac, t, \"mul\"\n\n    if s_norm > mu * max(r_norm, eps):\n        return rho / fac, t, \"div\"\n\n    return rho, t, \"keep\"\n\n```\nKey features: Performs well on combined_score (0.0430), Performs well on metrics ({'converged': True, 'iters': 23, 'combined_score': 0.043007227611818806}), Performs well on artifacts ({'status': 'CONVERGED', 'iterations': 23, 'eval_time': '0.021s'})\n\n\n\n# Current Program\n```python\n# initial_program.py\n# This file is evolved by AlphaEvolve\n# Only update_rho (and helpers) should be modified\n\nimport numpy as np\n\n\ndef tau(k, c=1.0, p=1.2):\n    \"\"\"\n    Diminishing step size, must be summable.\n    AlphaEvolve is allowed to change this.\n    \"\"\"\n    return c / ((k + 1) ** p)\n\n\ndef update_rho(\n    rho,\n    k,\n    r_norm,\n    s_norm,\n    mu=3.0,\n    c=1.0,\n    p=1.2,\n    eps=1e-12,\n):\n    \"\"\"\n    Adaptive ADMM penalty update rule.\n\n    Inputs:\n        rho    : current penalty parameter\n        k      : iteration index\n        r_norm : ||primal residual||\n        s_norm : ||dual residual||\n    Outputs:\n        new_rho : updated rho\n        aux     : any auxiliary scalar (logged but not used)\n        mode    : string label (\"mul\", \"div\", \"keep\", etc.)\n\n    AlphaEvolve may change the internal logic,\n    but MUST respect the signature and return types.\n    \"\"\"\n\n    t = tau(k, c, p)\n    fac = 0.85 + t\n\n    if r_norm > mu * max(s_norm, eps):\n        return rho * fac, t, \"mul\"\n\n    if s_norm > mu * max(r_norm, eps):\n        return rho / fac, t, \"div\"\n\n    return rho, t, \"keep\"\n\n```\n\n# Task\nSuggest improvements to the program that will improve its FITNESS SCORE.\nThe system maintains diversity across these dimensions: complexity, diversity\nDifferent solutions with similar fitness but different features are valuable.\n\nYou MUST use the exact SEARCH/REPLACE diff format shown below to indicate changes:\n\n<<<<<<< SEARCH\n# Original code to find and replace (must match exactly)\n=======\n# New replacement code\n>>>>>>> REPLACE\n\nExample of valid diff format:\n<<<<<<< SEARCH\nfor i in range(m):\n    for j in range(p):\n        for k in range(n):\n            C[i, j] += A[i, k] * B[k, j]\n=======\n# Reorder loops for better memory access pattern\nfor i in range(m):\n    for k in range(n):\n        for j in range(p):\n            C[i, j] += A[i, k] * B[k, j]\n>>>>>>> REPLACE\n\nYou can suggest multiple changes. Each SEARCH section must exactly match code in the current program.\nBe thoughtful about your changes and explain your reasoning thoroughly.\n\nIMPORTANT: Do not rewrite the entire program - focus on targeted improvements.", "responses": ["Looking at the current program, the `update_rho` function uses a fixed threshold `mu=3.0` and a factor `fac = 0.85 + t` where `t` is a diminishing step size. This approach may not be optimal for balancing primal and dual residuals efficiently, especially in early iterations where more aggressive updates could speed up convergence, and later iterations where stability is crucial.\n\nThe current strategy updates `rho` by multiplying or dividing by `fac`, which approaches 0.85 as `t` diminishes. This can lead to slower adjustments over time. To improve, we can:\n1. Use a more adaptive threshold that changes with iteration count\n2. Adjust the update factor based on the ratio of residuals\n3. Ensure updates are more aggressive early on and more conservative later\n\nLet's modify the function to:\n- Use a dynamic threshold that decreases over iterations to tighten the balance condition\n- Adjust the update factor based on the residual ratio for more precise adjustments\n- Add a stateful approach to prevent oscillations\n\nHowever, since we cannot add new parameters to the function signature, we can use the existing parameters cleverly.\n\nHere's a revised approach:\n1. Compute the ratio `ratio = r_norm / max(s_norm, eps)`\n2. Use a target ratio of 1.0 (balanced residuals)\n3. Update `rho` by `sqrt(ratio)` to bring it closer to balance\n4. But to prevent drastic changes, we can clip the update factor\n5. Also, make updates more aggressive in early iterations and less so later\n\nSince `tau(k)` is available, we can use it to control aggressiveness.\n\nLet's implement:\n\n<<<<<<< SEARCH\n    t = tau(k, c, p)\n    fac = 0.85 + t\n\n    if r_norm > mu * max(s_norm, eps):\n        return rho * fac, t, \"mul\"\n\n    if s_norm > mu * max(r_norm, eps):\n        return rho / fac, t, \"div\"\n\n    return rho, t, \"keep\"\n=======\n    t = tau(k, c, p)\n    # Early iterations: more aggressive, later: more conservative\n    # Use a dynamic threshold that tightens over time\n    # mu is scaled by (1 + t) to be more permissive early, stricter later\n    dynamic_mu = mu * (1.0 + 2.0 * t)  # Starts larger, decreases to mu\n    \n    # Compute the ratio of residuals\n    ratio = r_norm / max(s_norm, eps)\n    \n    # If ratio is too large, increase rho; if too small, decrease rho\n    # But we want to avoid oscillating, so update smoothly\n    # Target ratio is 1.0\n    if ratio > dynamic_mu:\n        # Increase rho to reduce primal residual\n        # Update factor based on sqrt(ratio) but bounded\n        fac = np.sqrt(ratio)\n        # Clip factor to prevent extreme updates\n        fac = min(fac, 1.5)\n        # Make updates more aggressive early on\n        fac = 1.0 + (fac - 1.0) * (1.0 - 0.5 * t)\n        new_rho = rho * fac\n        mode = \"mul\"\n    elif 1.0 / ratio > dynamic_mu:\n        # Decrease rho to reduce dual residual\n        fac = np.sqrt(1.0 / ratio)\n        fac = min(fac, 1.5)\n        fac = 1.0 + (fac - 1.0) * (1.0 - 0.5 * t)\n        new_rho = rho / fac\n        mode = \"div\"\n    else:\n        new_rho = rho\n        mode = \"keep\"\n    \n    # Ensure rho doesn't become too large or too small\n    # Clip to a reasonable range\n    rho_min = 1e-6\n    rho_max = 1e6\n    new_rho = max(rho_min, min(new_rho, rho_max))\n    \n    return new_rho, t, mode\n>>>>>>> REPLACE\n\nThis approach:\n1. Uses a dynamic threshold `dynamic_mu` that starts larger and decreases to `mu` over time, allowing more updates early on.\n2. Computes the actual ratio of residuals to guide updates more precisely.\n3. Updates `rho` by a factor based on the square root of the ratio, which is a common heuristic in ADMM.\n4. Clips the update factor to prevent extreme changes.\n5. Scales the aggressiveness with `t` (more aggressive early, less later).\n6. Clips `rho` to a reasonable range to maintain numerical stability.\n\nThis should lead to faster convergence by making more appropriate updates to `rho` at each iteration, balancing primal and dual residuals more effectively."]}}, "artifacts_json": null, "artifact_dir": null, "embedding": null}