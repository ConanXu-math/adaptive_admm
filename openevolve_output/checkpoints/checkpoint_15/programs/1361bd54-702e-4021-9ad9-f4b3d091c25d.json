{"id": "1361bd54-702e-4021-9ad9-f4b3d091c25d", "code": "# initial_program.py\n# This file is evolved by AlphaEvolve\n# Only update_rho (and helpers) should be modified\n\nimport numpy as np\n\n\ndef tau(k, c=1.0, p=1.2):\n    \"\"\"\n    Diminishing step size, must be summable.\n    AlphaEvolve is allowed to change this.\n    \"\"\"\n    return c / ((k + 1) ** p)\n\n\ndef update_rho(\n    rho,\n    k,\n    r_norm,\n    s_norm,\n    mu=3.0,\n    c=1.0,\n    p=1.2,\n    eps=1e-12,\n):\n    \"\"\"\n    Adaptive ADMM penalty update rule.\n\n    Inputs:\n        rho    : current penalty parameter\n        k      : iteration index\n        r_norm : ||primal residual||\n        s_norm : ||dual residual||\n    Outputs:\n        new_rho : updated rho\n        aux     : any auxiliary scalar (logged but not used)\n        mode    : string label (\"mul\", \"div\", \"keep\", etc.)\n\n    AlphaEvolve may change the internal logic,\n    but MUST respect the signature and return types.\n    \"\"\"\n    # Compute the ratio of primal to dual residual\n    ratio = r_norm / (s_norm + eps)\n    \n    # Target ratio is 1 (balanced residuals)\n    # Use log ratio to determine update direction and magnitude\n    log_ratio = np.log(ratio + 1e-16)  # Add small number to avoid log(0)\n    \n    # Determine update magnitude: more aggressive early, conservative later\n    # Use tau to control step size\n    t = tau(k, c, p)\n    \n    # Scale factor based on log ratio and iteration\n    # Clamp the exponent to prevent extreme updates\n    exponent = t * np.tanh(log_ratio)\n    \n    # Bound the update factor between 0.5 and 2.0\n    update_factor = np.exp(exponent)\n    update_factor = np.clip(update_factor, 0.5, 2.0)\n    \n    # Decide whether to update based on how far ratio is from 1\n    # If ratio is within [1/mu, mu], keep rho unchanged\n    if ratio > mu:\n        new_rho = rho * update_factor\n        mode = \"mul\"\n    elif ratio < 1.0/mu:\n        new_rho = rho / update_factor\n        mode = \"div\"\n    else:\n        new_rho = rho\n        mode = \"keep\"\n    \n    # Additional safeguard: prevent rho from becoming too large or too small\n    if new_rho > 1e6:\n        new_rho = 1e6\n        mode = \"clip\"\n    elif new_rho < 1e-6:\n        new_rho = 1e-6\n        mode = \"clip\"\n    \n    # Use log_ratio as auxiliary value\n    aux = log_ratio\n    return new_rho, aux, mode\n", "language": "python", "parent_id": "e3e7b7e1-1592-4d78-8c9c-6a76f7a88c15", "generation": 1, "timestamp": 1768219130.055134, "iteration_found": 6, "metrics": {"combined_score": 0.07669310862140852, "metrics": {"converged": true, "iters": 13, "combined_score": 0.07669310862140852}, "artifacts": {"status": "CONVERGED", "iterations": 13, "eval_time": "0.010s"}}, "complexity": 0.0, "diversity": 0.0, "metadata": {"changes": "Change 1: Replace 37 lines with 68 lines", "parent_metrics": {"combined_score": 0.043007227611818806, "metrics": {"converged": true, "iters": 23, "combined_score": 0.043007227611818806}, "artifacts": {"status": "CONVERGED", "iterations": 23, "eval_time": "0.021s"}}, "island": 0}, "prompts": {"diff_user": {"system": "You are an expert in numerical optimization and ADMM algorithms.\n\nYour task is to improve the function update_rho(rho, k, r_norm, s_norm, ...)\nused to adaptively update the ADMM penalty parameter.\n\nGoals:\n- Achieve faster convergence (fewer ADMM iterations)\n- Maintain numerical stability (avoid oscillating rho)\n- Balance primal and dual residuals efficiently\n\nConstraints:\n- You may ONLY modify the body of update_rho and helper functions in initial_program.py\n- The function signature and return types must remain unchanged\n- The code must be deterministic and numerically safe\n\nHints:\n- Consider using ratios or log-ratios of r_norm and s_norm\n- Early iterations may benefit from aggressive updates\n- Later iterations should favor stability\n- Piecewise or stateful strategies are allowed\n", "user": "# Current Program Information\n- Fitness: 0.0430\n- Feature coordinates: \n- Focus areas: - Fitness unchanged at 0.0430\n- No feature coordinates\n- Consider simplifying - code length exceeds 500 characters\n\n\n\n# Program Evolution History\n## Previous Attempts\n\n### Attempt 1\n- Changes: Unknown changes\n- Metrics: combined_score: 0.0430, metrics: {'converged': True, 'iters': 23, 'combined_score': 0.043007227611818806}, artifacts: {'status': 'CONVERGED', 'iterations': 23, 'eval_time': '0.021s'}\n- Outcome: Improvement in all metrics\n\n## Top Performing Programs\n\n### Program 1 (Score: 0.0430)\n```python\n# initial_program.py\n# This file is evolved by AlphaEvolve\n# Only update_rho (and helpers) should be modified\n\nimport numpy as np\n\n\ndef tau(k, c=1.0, p=1.2):\n    \"\"\"\n    Diminishing step size, must be summable.\n    AlphaEvolve is allowed to change this.\n    \"\"\"\n    return c / ((k + 1) ** p)\n\n\ndef update_rho(\n    rho,\n    k,\n    r_norm,\n    s_norm,\n    mu=3.0,\n    c=1.0,\n    p=1.2,\n    eps=1e-12,\n):\n    \"\"\"\n    Adaptive ADMM penalty update rule.\n\n    Inputs:\n        rho    : current penalty parameter\n        k      : iteration index\n        r_norm : ||primal residual||\n        s_norm : ||dual residual||\n    Outputs:\n        new_rho : updated rho\n        aux     : any auxiliary scalar (logged but not used)\n        mode    : string label (\"mul\", \"div\", \"keep\", etc.)\n\n    AlphaEvolve may change the internal logic,\n    but MUST respect the signature and return types.\n    \"\"\"\n\n    t = tau(k, c, p)\n    fac = 0.85 + t\n\n    if r_norm > mu * max(s_norm, eps):\n        return rho * fac, t, \"mul\"\n\n    if s_norm > mu * max(r_norm, eps):\n        return rho / fac, t, \"div\"\n\n    return rho, t, \"keep\"\n\n```\nKey features: Performs well on combined_score (0.0430), Performs well on metrics ({'converged': True, 'iters': 23, 'combined_score': 0.043007227611818806}), Performs well on artifacts ({'status': 'CONVERGED', 'iterations': 23, 'eval_time': '0.021s'})\n\n\n\n# Current Program\n```python\n# initial_program.py\n# This file is evolved by AlphaEvolve\n# Only update_rho (and helpers) should be modified\n\nimport numpy as np\n\n\ndef tau(k, c=1.0, p=1.2):\n    \"\"\"\n    Diminishing step size, must be summable.\n    AlphaEvolve is allowed to change this.\n    \"\"\"\n    return c / ((k + 1) ** p)\n\n\ndef update_rho(\n    rho,\n    k,\n    r_norm,\n    s_norm,\n    mu=3.0,\n    c=1.0,\n    p=1.2,\n    eps=1e-12,\n):\n    \"\"\"\n    Adaptive ADMM penalty update rule.\n\n    Inputs:\n        rho    : current penalty parameter\n        k      : iteration index\n        r_norm : ||primal residual||\n        s_norm : ||dual residual||\n    Outputs:\n        new_rho : updated rho\n        aux     : any auxiliary scalar (logged but not used)\n        mode    : string label (\"mul\", \"div\", \"keep\", etc.)\n\n    AlphaEvolve may change the internal logic,\n    but MUST respect the signature and return types.\n    \"\"\"\n\n    t = tau(k, c, p)\n    fac = 0.85 + t\n\n    if r_norm > mu * max(s_norm, eps):\n        return rho * fac, t, \"mul\"\n\n    if s_norm > mu * max(r_norm, eps):\n        return rho / fac, t, \"div\"\n\n    return rho, t, \"keep\"\n\n```\n\n# Task\nSuggest improvements to the program that will improve its FITNESS SCORE.\nThe system maintains diversity across these dimensions: complexity, diversity\nDifferent solutions with similar fitness but different features are valuable.\n\nYou MUST use the exact SEARCH/REPLACE diff format shown below to indicate changes:\n\n<<<<<<< SEARCH\n# Original code to find and replace (must match exactly)\n=======\n# New replacement code\n>>>>>>> REPLACE\n\nExample of valid diff format:\n<<<<<<< SEARCH\nfor i in range(m):\n    for j in range(p):\n        for k in range(n):\n            C[i, j] += A[i, k] * B[k, j]\n=======\n# Reorder loops for better memory access pattern\nfor i in range(m):\n    for k in range(n):\n        for j in range(p):\n            C[i, j] += A[i, k] * B[k, j]\n>>>>>>> REPLACE\n\nYou can suggest multiple changes. Each SEARCH section must exactly match code in the current program.\nBe thoughtful about your changes and explain your reasoning thoroughly.\n\nIMPORTANT: Do not rewrite the entire program - focus on targeted improvements.", "responses": ["Looking at the current implementation, the update strategy uses a fixed threshold `mu=3.0` and a factor `fac = 0.85 + t` where `t` diminishes over iterations. This approach can be improved by making the update more adaptive to the ratio between primal and dual residuals, and by adjusting the update magnitude based on the iteration.\n\nThe current strategy may be too conservative in early iterations and too aggressive in later ones. Let's consider a more balanced approach:\n1. Use the ratio `r_norm / (s_norm + eps)` to guide updates\n2. Make updates more aggressive when the ratio is far from 1\n3. Reduce update magnitude as iterations progress to ensure stability\n4. Use a stateful approach to prevent oscillations\n\nHowever, note that we cannot add new parameters to the function signature. We can use the existing parameters creatively.\n\nHere's an improved approach:\n1. Compute the ratio of residuals\n2. Use a target ratio of 1 (balanced residuals)\n3. Update rho by raising it to a power that depends on the log ratio\n4. Bound the update to prevent extreme changes\n5. Make updates more conservative as iterations increase\n\nLet's implement this:\n\n<<<<<<< SEARCH\ndef update_rho(\n    rho,\n    k,\n    r_norm,\n    s_norm,\n    mu=3.0,\n    c=1.0,\n    p=1.2,\n    eps=1e-12,\n):\n    \"\"\"\n    Adaptive ADMM penalty update rule.\n\n    Inputs:\n        rho    : current penalty parameter\n        k      : iteration index\n        r_norm : ||primal residual||\n        s_norm : ||dual residual||\n    Outputs:\n        new_rho : updated rho\n        aux     : any auxiliary scalar (logged but not used)\n        mode    : string label (\"mul\", \"div\", \"keep\", etc.)\n\n    AlphaEvolve may change the internal logic,\n    but MUST respect the signature and return types.\n    \"\"\"\n\n    t = tau(k, c, p)\n    fac = 0.85 + t\n\n    if r_norm > mu * max(s_norm, eps):\n        return rho * fac, t, \"mul\"\n\n    if s_norm > mu * max(r_norm, eps):\n        return rho / fac, t, \"div\"\n\n    return rho, t, \"keep\"\n=======\ndef update_rho(\n    rho,\n    k,\n    r_norm,\n    s_norm,\n    mu=3.0,\n    c=1.0,\n    p=1.2,\n    eps=1e-12,\n):\n    \"\"\"\n    Adaptive ADMM penalty update rule.\n\n    Inputs:\n        rho    : current penalty parameter\n        k      : iteration index\n        r_norm : ||primal residual||\n        s_norm : ||dual residual||\n    Outputs:\n        new_rho : updated rho\n        aux     : any auxiliary scalar (logged but not used)\n        mode    : string label (\"mul\", \"div\", \"keep\", etc.)\n\n    AlphaEvolve may change the internal logic,\n    but MUST respect the signature and return types.\n    \"\"\"\n    # Compute the ratio of primal to dual residual\n    ratio = r_norm / (s_norm + eps)\n    \n    # Target ratio is 1 (balanced residuals)\n    # Use log ratio to determine update direction and magnitude\n    log_ratio = np.log(ratio + 1e-16)  # Add small number to avoid log(0)\n    \n    # Determine update magnitude: more aggressive early, conservative later\n    # Use tau to control step size\n    t = tau(k, c, p)\n    \n    # Scale factor based on log ratio and iteration\n    # Clamp the exponent to prevent extreme updates\n    exponent = t * np.tanh(log_ratio)\n    \n    # Bound the update factor between 0.5 and 2.0\n    update_factor = np.exp(exponent)\n    update_factor = np.clip(update_factor, 0.5, 2.0)\n    \n    # Decide whether to update based on how far ratio is from 1\n    # If ratio is within [1/mu, mu], keep rho unchanged\n    if ratio > mu:\n        new_rho = rho * update_factor\n        mode = \"mul\"\n    elif ratio < 1.0/mu:\n        new_rho = rho / update_factor\n        mode = \"div\"\n    else:\n        new_rho = rho\n        mode = \"keep\"\n    \n    # Additional safeguard: prevent rho from becoming too large or too small\n    if new_rho > 1e6:\n        new_rho = 1e6\n        mode = \"clip\"\n    elif new_rho < 1e-6:\n        new_rho = 1e-6\n        mode = \"clip\"\n    \n    # Use log_ratio as auxiliary value\n    aux = log_ratio\n    return new_rho, aux, mode\n>>>>>>> REPLACE\n\nThis implementation:\n1. Uses the ratio of residuals directly, which is more intuitive than comparing each to the other scaled by mu\n2. Updates rho by multiplying or dividing by a factor that depends on the log ratio, which gives smooth updates\n3. The update factor is bounded to prevent extreme changes\n4. Uses tanh to keep the exponent bounded\n5. Becomes more conservative as iterations increase due to t decreasing\n6. Includes safeguards to prevent numerical issues\n\nHowever, note that the original implementation used mu=3.0 as a threshold. We maintain this by only updating when ratio > mu or ratio < 1/mu, which is equivalent to r_norm > mu*s_norm or s_norm > mu*r_norm.\n\nThis approach should lead to faster convergence by making more appropriate updates to rho, especially in early iterations where t is larger, while maintaining stability in later iterations."]}}, "artifacts_json": null, "artifact_dir": null, "embedding": null}